{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === \"undefined\" || o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } i = o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"](); return i.next.bind(i); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport pathToRegexp from 'path-to-regexp';\nimport NavigationActions from \"../NavigationActions\";\nimport StackActions from \"./StackActions\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport StateUtils from \"../StateUtils\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport invariant from \"../utils/invariant\";\nimport { generateKey } from \"./KeyGenerator\";\nimport getNavigationActionCreators from \"./getNavigationActionCreators\";\n\nfunction isEmpty(obj) {\n  if (!obj) return true;\n\n  for (var key in obj) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === StackActions.PUSH;\n}\n\nvar defaultActionCreators = function defaultActionCreators(route, navStateKey) {\n  return {};\n};\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (function (routeConfigs) {\n  var stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var childRouters = {};\n  var routeNames = Object.keys(routeConfigs);\n  routeNames.forEach(function (routeName) {\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen && screen.router) {\n      childRouters[routeName] = screen.router;\n    } else {\n      childRouters[routeName] = null;\n    }\n  });\n  var initialRouteParams = stackConfig.initialRouteParams;\n  var getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  var initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  var initialChildRouter = childRouters[initialRouteName];\n  var pathsByRouteNames = _objectSpread({}, stackConfig.paths) || {};\n  var paths = [];\n\n  function getInitialState(action) {\n    var route = {};\n    var childRouter = childRouters[action.routeName];\n\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      var childState = {};\n\n      if (childRouter !== null) {\n        var childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [_objectSpread({\n          params: action.params\n        }, childState, {\n          key: action.key || generateKey(),\n          routeName: action.routeName\n        })]\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n\n    var params = (route.params || action.params || initialRouteParams) && _objectSpread({}, route.params || {}, {}, action.params || {}, {}, initialRouteParams || {});\n\n    var initialRouteKey = stackConfig.initialRouteKey;\n    route = _objectSpread({}, route, {}, params ? {\n      params: params\n    } : {}, {\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey()\n    });\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n\n  routeNames.forEach(function (routeName) {\n    var pathPattern = pathsByRouteNames[routeName] || routeConfigs[routeName].path;\n    var matchExact = !!pathPattern && !childRouters[routeName];\n\n    if (pathPattern === undefined) {\n      pathPattern = routeName;\n    }\n\n    var keys = [];\n    var re, toPath, priority;\n\n    if (typeof pathPattern === 'string') {\n      re = pathToRegexp(pathPattern, keys);\n      toPath = pathToRegexp.compile(pathPattern);\n      priority = 0;\n    } else {\n      re = pathToRegexp('*', keys);\n\n      toPath = function toPath() {\n        return '';\n      };\n\n      matchExact = true;\n      priority = -1;\n    }\n\n    if (!matchExact) {\n      var wildcardRe = pathToRegexp(pathPattern + \"/*\", keys);\n      re = new RegExp(\"(?:\" + re.source + \")|(?:\" + wildcardRe.source + \")\");\n    }\n\n    pathsByRouteNames[routeName] = {\n      re: re,\n      keys: keys,\n      toPath: toPath,\n      priority: priority\n    };\n  });\n  paths = Object.entries(pathsByRouteNames);\n  paths.sort(function (a, b) {\n    return b[1].priority - a[1].priority;\n  });\n  return {\n    getComponentForState: function getComponentForState(state) {\n      var activeChildRoute = state.routes[state.index];\n      var routeName = activeChildRoute.routeName;\n\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getActionCreators: function getActionCreators(route, navStateKey) {\n      return _objectSpread({}, getNavigationActionCreators(route), {}, getCustomActionCreators(route, navStateKey), {\n        pop: function pop(n, params) {\n          return StackActions.pop(_objectSpread({\n            n: n\n          }, params));\n        },\n        popToTop: function popToTop(params) {\n          return StackActions.popToTop(params);\n        },\n        push: function push(routeName, params, action) {\n          return StackActions.push({\n            routeName: routeName,\n            params: params,\n            action: action\n          });\n        },\n        replace: function replace(replaceWith, params, action, newKey) {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params: params,\n              action: action,\n              key: route.key,\n              newKey: newKey\n            });\n          }\n\n          invariant(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          invariant(params == null, 'Params must not be provided to .replace() when specifying an object');\n          invariant(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          invariant(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return StackActions.replace(replaceWith);\n        },\n        reset: function reset(actions, index) {\n          return StackActions.reset({\n            actions: actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey\n          });\n        },\n        dismiss: function dismiss() {\n          return NavigationActions.back({\n            key: navStateKey\n          });\n        }\n      });\n    },\n    getStateForAction: function getStateForAction(action, state) {\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      if (!isResetToRootStack(action) && action.type !== NavigationActions.NAVIGATE) {\n        var keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n        var childIndex = keyIndex >= 0 ? keyIndex : state.index;\n        var childRoute = state.routes[childIndex];\n        invariant(childRoute, \"StateUtils erroneously thought index \" + childIndex + \" exists\");\n        var childRouter = childRouters[childRoute.routeName];\n\n        if (childRouter) {\n          var route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          }\n\n          if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        for (var _iterator = _createForOfIteratorHelperLoose(state.routes.slice().reverse()), _step; !(_step = _iterator()).done;) {\n          var _childRoute = _step.value;\n          var _childRouter = childRouters[_childRoute.routeName];\n          var childAction = action.routeName === _childRoute.routeName && action.action ? action.action : action;\n\n          if (_childRouter) {\n            var nextRouteState = _childRouter.getStateForAction(childAction, _childRoute);\n\n            if (nextRouteState === null || nextRouteState !== _childRoute) {\n              return StateUtils.replaceAndPrune(state, nextRouteState ? nextRouteState.key : _childRoute.key, nextRouteState ? nextRouteState : _childRoute);\n            }\n          }\n        }\n      }\n\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        var _childRouter2 = childRouters[action.routeName];\n\n        var _route;\n\n        invariant(action.type !== StackActions.PUSH || action.key == null, 'StackRouter does not support key on the push action');\n        var lastRouteIndex = state.routes.findIndex(function (r) {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          var routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          if (action.params) {\n            var _route2 = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = _objectSpread({}, _route2, {\n              params: _objectSpread({}, _route2.params, {}, action.params)\n            });\n          }\n\n          return _objectSpread({}, state, {\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes: routes\n          });\n        }\n\n        if (_childRouter2) {\n          var _childAction = action.action || NavigationActions.init({\n            params: action.params\n          });\n\n          _route = _objectSpread({\n            params: action.params\n          }, _childRouter2.getStateForAction(_childAction), {\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          });\n        } else {\n          _route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        }\n\n        return _objectSpread({}, StateUtils.push(state, _route), {\n          isTransitioning: action.immediate !== true\n        });\n      } else if (action.type === StackActions.PUSH && childRouters[action.routeName] === undefined) {\n        return state;\n      }\n\n      if (behavesLikePushAction(action)) {\n        var childRouterNames = Object.keys(childRouters);\n\n        for (var i = 0; i < childRouterNames.length; i++) {\n          var childRouterName = childRouterNames[i];\n          var _childRouter3 = childRouters[childRouterName];\n\n          if (_childRouter3) {\n            var initChildRoute = _childRouter3.getStateForAction(NavigationActions.init());\n\n            var navigatedChildRoute = _childRouter3.getStateForAction(action, initChildRoute);\n\n            var routeToPush = null;\n\n            if (navigatedChildRoute === null) {\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              routeToPush = navigatedChildRoute;\n            }\n\n            if (routeToPush) {\n              var _route3 = _objectSpread({}, routeToPush, {\n                routeName: childRouterName,\n                key: action.key || generateKey()\n              });\n\n              return StateUtils.push(state, _route3);\n            }\n          }\n        }\n      }\n\n      if (action.type === StackActions.POP_TO_TOP) {\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        if (state.index > 0) {\n          return _objectSpread({}, state, {\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          });\n        }\n\n        return state;\n      }\n\n      if (action.type === StackActions.REPLACE) {\n        var routeIndex = state.routes.findIndex(function (r) {\n          return r.key === action.key;\n        });\n\n        if (routeIndex !== -1) {\n          var _childRouter4 = childRouters[action.routeName];\n          var childState = {};\n\n          if (_childRouter4) {\n            var _childAction2 = action.action || NavigationActions.init({\n              params: action.params\n            });\n\n            childState = _childRouter4.getStateForAction(_childAction2);\n          }\n\n          var _routes = _toConsumableArray(state.routes);\n\n          _routes[routeIndex] = _objectSpread({\n            params: action.params\n          }, childState, {\n            routeName: action.routeName,\n            key: action.newKey || generateKey()\n          });\n          return _objectSpread({}, state, {\n            routes: _routes\n          });\n        }\n      }\n\n      if (action.type === StackActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && state.isTransitioning) {\n        return _objectSpread({}, state, {\n          isTransitioning: false\n        });\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var params = _objectSpread({}, lastRoute.params, {}, action.params);\n\n          var _routes2 = _toConsumableArray(state.routes);\n\n          _routes2[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: params\n          });\n          return _objectSpread({}, state, {\n            routes: _routes2\n          });\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        if (action.key != null && action.key != state.key) {\n          return state;\n        }\n\n        var newStackActions = action.actions;\n        return _objectSpread({}, state, {\n          routes: newStackActions.map(function (newStackAction) {\n            var router = childRouters[newStackAction.routeName];\n            var childState = {};\n\n            if (router) {\n              var _childAction3 = newStackAction.action || NavigationActions.init({\n                params: newStackAction.params\n              });\n\n              childState = router.getStateForAction(_childAction3);\n            }\n\n            return _objectSpread({\n              params: newStackAction.params\n            }, childState, {\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey()\n            });\n          }),\n          index: action.index\n        });\n      }\n\n      if (action.type === NavigationActions.BACK || action.type === StackActions.POP) {\n        var _key = action.key,\n            n = action.n,\n            immediate = action.immediate;\n        var backRouteIndex = state.index;\n\n        if (action.type === StackActions.POP && n != null) {\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (_key) {\n          var backRoute = state.routes.find(function (route) {\n            return route.key === _key;\n          });\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return _objectSpread({}, state, {\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true\n          });\n        }\n      }\n\n      return state;\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      var routeName = route.routeName;\n      var screen = getScreenForRouteName(routeConfigs, routeName);\n      var subPath = pathsByRouteNames[routeName].toPath(route.params);\n      var path = subPath;\n      var params = route.params;\n\n      if (screen && screen.router) {\n        var stateRoute = route;\n        var child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? subPath + \"/\" + child.path : child.path;\n        params = child.params ? _objectSpread({}, params, {}, child.params) : params;\n      }\n\n      return {\n        path: path,\n        params: params\n      };\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(pathToResolve, inputParams) {\n      if (!pathToResolve) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: inputParams\n        });\n      }\n\n      var _pathToResolve$split = pathToResolve.split('?'),\n          _pathToResolve$split2 = _slicedToArray(_pathToResolve$split, 2),\n          pathNameToResolve = _pathToResolve$split2[0],\n          queryString = _pathToResolve$split2[1];\n\n      var matchedRouteName;\n      var pathMatch;\n      var pathMatchKeys;\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(paths), _step2; !(_step2 = _iterator2()).done;) {\n        var _ref = _step2.value;\n\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var routeName = _ref2[0];\n        var path = _ref2[1];\n        var re = path.re,\n            keys = path.keys;\n        pathMatch = re.exec(pathNameToResolve);\n\n        if (pathMatch && pathMatch.length) {\n          pathMatchKeys = keys;\n          matchedRouteName = routeName;\n          break;\n        }\n      }\n\n      if (!matchedRouteName) {\n        if (!pathToResolve) {\n          return NavigationActions.navigate({\n            routeName: initialRouteName\n          });\n        }\n\n        return null;\n      }\n\n      var nestedAction;\n      var nestedQueryString = queryString ? '?' + queryString : '';\n\n      if (childRouters[matchedRouteName]) {\n        nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(pathMatch.slice(pathMatchKeys.length).join('/') + nestedQueryString);\n\n        if (!nestedAction) {\n          return null;\n        }\n      }\n\n      var queryParams = !isEmpty(inputParams) ? inputParams : (queryString || '').split('&').reduce(function (result, item) {\n        if (item !== '') {\n          var nextResult = result || {};\n\n          var _item$split = item.split('='),\n              _item$split2 = _slicedToArray(_item$split, 2),\n              key = _item$split2[0],\n              value = _item$split2[1];\n\n          nextResult[key] = value;\n          return nextResult;\n        }\n\n        return result;\n      }, null);\n      var params = pathMatch.slice(1).reduce(function (result, matchResult, i) {\n        var key = pathMatchKeys[i];\n\n        if (key.asterisk || !key) {\n          return result;\n        }\n\n        var nextResult = result || inputParams || {};\n        var paramName = key.name;\n        var decodedMatchResult;\n\n        try {\n          decodedMatchResult = decodeURIComponent(matchResult);\n        } catch (e) {}\n\n        nextResult[paramName] = decodedMatchResult || matchResult;\n        return nextResult;\n      }, queryParams);\n      return NavigationActions.navigate(_objectSpread({\n        routeName: matchedRouteName\n      }, params ? {\n        params: params\n      } : {}, {}, nestedAction ? {\n        action: nestedAction\n      } : {}));\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, stackConfig.navigationOptions)\n  };\n});","map":{"version":3,"sources":["/home/narensairam/Desktop/react-native/fixtures/node_modules/react-navigation/src/routers/StackRouter.js"],"names":["pathToRegexp","NavigationActions","StackActions","createConfigGetter","getScreenForRouteName","StateUtils","validateRouteConfigMap","invariant","generateKey","getNavigationActionCreators","isEmpty","obj","key","behavesLikePushAction","action","type","NAVIGATE","PUSH","defaultActionCreators","route","navStateKey","isResetToRootStack","RESET","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","pathsByRouteNames","paths","getInitialState","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","pathPattern","path","matchExact","re","toPath","priority","compile","wildcardRe","RegExp","source","entries","sort","a","b","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","length","dismiss","back","keyIndex","indexOf","childIndex","childRoute","replaceAt","slice","reverse","nextRouteState","replaceAndPrune","lastRouteIndex","findIndex","r","immediate","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","COMPLETE_TRANSITION","SET_PARAMS","lastRoute","find","newStackActions","map","newStackAction","BACK","POP","backRouteIndex","Math","max","backRoute","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","pathToResolve","inputParams","split","pathNameToResolve","queryString","matchedRouteName","pathMatch","pathMatchKeys","exec","nestedAction","nestedQueryString","join","queryParams","reduce","result","item","nextResult","value","matchResult","asterisk","paramName","name","decodedMatchResult","decodeURIComponent","e","getScreenOptions","navigationOptions"],"mappings":"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","sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\nimport NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport getNavigationActionCreators from './getNavigationActionCreators';\n\nfunction isEmpty(obj) {\n  if (!obj) return true;\n  for (let key in obj) {\n    return false;\n  }\n  return true;\n}\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = (route, navStateKey) => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n  const pathsByRouteNames = { ...stackConfig.paths } || {};\n  let paths = [];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (route.params || action.params || initialRouteParams) && {\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || (initialRouteKey || generateKey()),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  // Build paths for each route\n  routeNames.forEach(routeName => {\n    let pathPattern =\n      pathsByRouteNames[routeName] || routeConfigs[routeName].path;\n    let matchExact = !!pathPattern && !childRouters[routeName];\n    if (pathPattern === undefined) {\n      pathPattern = routeName;\n    }\n    const keys = [];\n    let re, toPath, priority;\n    if (typeof pathPattern === 'string') {\n      // pathPattern may be either a string or a regexp object according to path-to-regexp docs.\n      re = pathToRegexp(pathPattern, keys);\n      toPath = pathToRegexp.compile(pathPattern);\n      priority = 0;\n    } else {\n      // for wildcard match\n      re = pathToRegexp('*', keys);\n      toPath = () => '';\n      matchExact = true;\n      priority = -1;\n    }\n    if (!matchExact) {\n      const wildcardRe = pathToRegexp(`${pathPattern}/*`, keys);\n      re = new RegExp(`(?:${re.source})|(?:${wildcardRe.source})`);\n    }\n    pathsByRouteNames[routeName] = { re, keys, toPath, priority };\n  });\n\n  paths = Object.entries(pathsByRouteNames);\n  paths.sort((a, b) => b[1].priority - a[1].priority);\n\n  return {\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getNavigationActionCreators(route),\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      // Check if the focused child scene wants to handle the action, as long as\n      // it is not a reset to the root stack\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        const keyIndex = action.key\n          ? StateUtils.indexOf(state, action.key)\n          : -1;\n        const childIndex = keyIndex >= 0 ? keyIndex : state.index;\n        const childRoute = state.routes[childIndex];\n        invariant(\n          childRoute,\n          `StateUtils erroneously thought index ${childIndex} exists`\n        );\n        const childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n          if (route === null) {\n            return state;\n          }\n          if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              return StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n            }\n          }\n        }\n      }\n\n      // Handle explicit push navigation action. This must happen after the\n      // focused child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          const childAction =\n            action.action || NavigationActions.init({ params: action.params });\n          route = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return StateUtils.push(state, route);\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        const routeIndex = state.routes.findIndex(r => r.key === action.key);\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({ params: action.params });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({ params: newStackAction.params });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: newStackAction.params,\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate } = action;\n        let backRouteIndex = state.index;\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true,\n          };\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      const routeName = route.routeName;\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      const subPath = pathsByRouteNames[routeName].toPath(route.params);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        const stateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    getActionForPathAndParams(pathToResolve, inputParams) {\n      // If the path is empty (null or empty string)\n      // just return the initial route action\n      if (!pathToResolve) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: inputParams,\n        });\n      }\n\n      const [pathNameToResolve, queryString] = pathToResolve.split('?');\n\n      // Attempt to match `pathNameToResolve` with a route in this router's\n      // routeConfigs\n      let matchedRouteName;\n      let pathMatch;\n      let pathMatchKeys;\n\n      // eslint-disable-next-line no-restricted-syntax\n      for (const [routeName, path] of paths) {\n        const { re, keys } = path;\n        pathMatch = re.exec(pathNameToResolve);\n        if (pathMatch && pathMatch.length) {\n          pathMatchKeys = keys;\n          matchedRouteName = routeName;\n          break;\n        }\n      }\n\n      // We didn't match -- return null\n      if (!matchedRouteName) {\n        // If the path is empty (null or empty string)\n        // just return the initial route action\n        if (!pathToResolve) {\n          return NavigationActions.navigate({\n            routeName: initialRouteName,\n          });\n        }\n        return null;\n      }\n\n      // Determine nested actions:\n      // If our matched route for this router is a child router,\n      // get the action for the path AFTER the matched path for this\n      // router\n      let nestedAction;\n      let nestedQueryString = queryString ? '?' + queryString : '';\n      if (childRouters[matchedRouteName]) {\n        nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(\n          pathMatch.slice(pathMatchKeys.length).join('/') + nestedQueryString\n        );\n        if (!nestedAction) {\n          return null;\n        }\n      }\n\n      // reduce the items of the query string. any query params may\n      // be overridden by path params\n      const queryParams = !isEmpty(inputParams)\n        ? inputParams\n        : (queryString || '').split('&').reduce((result, item) => {\n            if (item !== '') {\n              const nextResult = result || {};\n              const [key, value] = item.split('=');\n              nextResult[key] = value;\n              return nextResult;\n            }\n            return result;\n          }, null);\n\n      // reduce the matched pieces of the path into the params\n      // of the route. `params` is null if there are no params.\n      const params = pathMatch.slice(1).reduce((result, matchResult, i) => {\n        const key = pathMatchKeys[i];\n        if (key.asterisk || !key) {\n          return result;\n        }\n        const nextResult = result || inputParams || {};\n        const paramName = key.name;\n\n        let decodedMatchResult;\n        try {\n          decodedMatchResult = decodeURIComponent(matchResult);\n        } catch (e) {\n          // ignore `URIError: malformed URI`\n        }\n\n        nextResult[paramName] = decodedMatchResult || matchResult;\n        return nextResult;\n      }, queryParams);\n\n      return NavigationActions.navigate({\n        routeName: matchedRouteName,\n        ...(params ? { params } : {}),\n        ...(nestedAction ? { action: nestedAction } : {}),\n      });\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.navigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}