{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from \"../utils/invariant\";\nimport getScreenForRouteName from \"./getScreenForRouteName\";\nimport createConfigGetter from \"./createConfigGetter\";\nimport NavigationActions from \"../NavigationActions\";\nimport StackActions from \"./StackActions\";\nimport validateRouteConfigMap from \"./validateRouteConfigMap\";\nimport getNavigationActionCreators from \"./getNavigationActionCreators\";\n\nvar defaultActionCreators = function defaultActionCreators(route, navStateKey) {\n  return {};\n};\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [NavigationActions.SET_PARAMS, StackActions.COMPLETE_TRANSITION].includes(actionType);\n}\n\nexport default (function (routeConfigs) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validateRouteConfigMap(routeConfigs);\n  var order = config.order || Object.keys(routeConfigs);\n  var paths = config.paths || {};\n  var getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  var initialRouteParams = config.initialRouteParams;\n  var initialRouteName = config.initialRouteName || order[0];\n  var backBehavior = config.backBehavior || 'none';\n  var shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  var resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  var initialRouteIndex = order.indexOf(initialRouteName);\n  var childRouters = {};\n  order.forEach(function (routeName) {\n    var routeConfig = routeConfigs[routeName];\n\n    if (!paths[routeName]) {\n      paths[routeName] = typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    }\n\n    childRouters[routeName] = null;\n    var screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\" + initialRouteName + \"'.\" + (\"Should be one of \" + order.map(function (n) {\n      return \"\\\"\" + n + \"\\\"\";\n    }).join(', ')));\n  }\n\n  function resetChildRoute(routeName) {\n    var params = routeName === initialRouteName ? initialRouteParams : undefined;\n    var childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      var childAction = NavigationActions.init();\n      return _objectSpread({}, childRouter.getStateForAction(childAction), {\n        key: routeName,\n        routeName: routeName,\n        params: params\n      });\n    }\n\n    return {\n      key: routeName,\n      routeName: routeName,\n      params: params\n    };\n  }\n\n  return {\n    getInitialState: function getInitialState() {\n      var routes = order.map(resetChildRoute);\n      return {\n        routes: routes,\n        index: initialRouteIndex,\n        isTransitioning: false\n      };\n    },\n    getNextState: function getNextState(prevState, possibleNextState) {\n      if (!prevState) {\n        return possibleNextState;\n      }\n\n      var nextState;\n\n      if (prevState.index !== possibleNextState.index && resetOnBlur) {\n        var prevRouteName = prevState.routes[prevState.index].routeName;\n\n        var nextRoutes = _toConsumableArray(possibleNextState.routes);\n\n        nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n        return _objectSpread({}, possibleNextState, {\n          routes: nextRoutes\n        });\n      } else {\n        nextState = possibleNextState;\n      }\n\n      return nextState;\n    },\n    getActionCreators: function getActionCreators(route, stateKey) {\n      return _objectSpread({}, getNavigationActionCreators(route), {}, getCustomActionCreators(route, stateKey));\n    },\n    getStateForAction: function getStateForAction(action, inputState) {\n      var prevState = inputState ? _objectSpread({}, inputState) : inputState;\n      var state = inputState || this.getInitialState();\n      var activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        var params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(function (route) {\n            return _objectSpread({}, route, {\n              params: _objectSpread({}, route.params, {}, params, {}, route.routeName === initialRouteName ? initialRouteParams : null)\n            });\n          });\n        }\n      }\n\n      var activeChildLastState = state.routes[state.index];\n      var activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        var activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          var _routes = _toConsumableArray(state.routes);\n\n          _routes[state.index] = activeChildState;\n          return this.getNextState(prevState, _objectSpread({}, state, {\n            routes: _routes\n          }));\n        }\n      }\n\n      var isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && shouldBackNavigateToInitialRoute) {\n          activeChildIndex = initialRouteIndex;\n        } else {\n          return state;\n        }\n      }\n\n      var didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find(function (childId, i) {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          var childState = state.routes[activeChildIndex];\n          var childRouter = childRouters[action.routeName];\n          var newChildState;\n\n          if (action.action) {\n            newChildState = childRouter ? childRouter.getStateForAction(action.action, childState) : null;\n          } else if (!action.action && !childRouter && action.params) {\n            newChildState = _objectSpread({}, childState, {\n              params: _objectSpread({}, childState.params || {}, {}, action.params)\n            });\n          }\n\n          if (newChildState && newChildState !== childState) {\n            var _routes2 = _toConsumableArray(state.routes);\n\n            _routes2[activeChildIndex] = newChildState;\n            return this.getNextState(prevState, _objectSpread({}, state, {\n              routes: _routes2,\n              index: activeChildIndex\n            }));\n          } else if (!newChildState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        var key = action.key;\n        var lastRoute = state.routes.find(function (route) {\n          return route.key === key;\n        });\n\n        if (lastRoute) {\n          var _params = _objectSpread({}, lastRoute.params, {}, action.params);\n\n          var _routes3 = _toConsumableArray(state.routes);\n\n          _routes3[state.routes.indexOf(lastRoute)] = _objectSpread({}, lastRoute, {\n            params: _params\n          });\n          return this.getNextState(prevState, _objectSpread({}, state, {\n            routes: _routes3\n          }));\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return this.getNextState(prevState, _objectSpread({}, state, {\n          index: activeChildIndex\n        }));\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return _objectSpread({}, state);\n      }\n\n      var index = state.index;\n      var routes = state.routes;\n      order.find(function (childId, i) {\n        var childRouter = childRouters[childId];\n\n        if (i === index) {\n          return false;\n        }\n\n        var childState = routes[i];\n\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n\n        if (!childState) {\n          index = i;\n          return true;\n        }\n\n        if (childState !== routes[i]) {\n          routes = _toConsumableArray(routes);\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return this.getNextState(prevState, _objectSpread({}, state, {\n          index: index,\n          routes: routes\n        }));\n      }\n\n      return state;\n    },\n    getComponentForState: function getComponentForState(state) {\n      var routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \" + state.index + \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\");\n      var childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getComponentForRouteName: function getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n    getPathAndParamsForState: function getPathAndParamsForState(state) {\n      var route = state.routes[state.index];\n      var routeName = order[state.index];\n      var subPath = paths[routeName];\n      var screen = getScreenForRouteName(routeConfigs, routeName);\n      var path = subPath;\n      var params = route.params;\n\n      if (screen && screen.router) {\n        var stateRoute = route;\n        var child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? subPath + \"/\" + child.path : child.path;\n        params = child.params ? _objectSpread({}, params, {}, child.params) : params;\n      }\n\n      return {\n        path: path,\n        params: params\n      };\n    },\n    getActionForPathAndParams: function getActionForPathAndParams(path, params) {\n      if (!path) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: params\n        });\n      }\n\n      return order.map(function (childId) {\n        var parts = path.split('/');\n        var pathToTest = paths[childId];\n        var partsInTestPath = pathToTest.split('/').length;\n        var pathPartsToTest = parts.slice(0, partsInTestPath).join('/');\n\n        if (pathPartsToTest === pathToTest) {\n          var childRouter = childRouters[childId];\n          var action = NavigationActions.navigate({\n            routeName: childId\n          });\n\n          if (childRouter && childRouter.getActionForPathAndParams) {\n            action.action = childRouter.getActionForPathAndParams(parts.slice(partsInTestPath).join('/'), params);\n          }\n\n          if (params) {\n            action.params = params;\n          }\n\n          return action;\n        }\n\n        return null;\n      }).find(function (action) {\n        return !!action;\n      }) || order.map(function (childId) {\n        var childRouter = childRouters[childId];\n        return childRouter && childRouter.getActionForPathAndParams(path, params);\n      }).find(function (action) {\n        return !!action;\n      }) || null;\n    },\n    getScreenOptions: createConfigGetter(routeConfigs, config.navigationOptions)\n  };\n});","map":{"version":3,"sources":["/home/narensairam/Desktop/react-native/fixtures/node_modules/react-navigation/src/routers/SwitchRouter.js"],"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","StackActions","validateRouteConfigMap","getNavigationActionCreators","defaultActionCreators","route","navStateKey","childrenUpdateWithoutSwitchingIndex","actionType","SET_PARAMS","COMPLETE_TRANSITION","includes","routeConfigs","config","order","Object","keys","paths","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","shouldBackNavigateToInitialRoute","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","childRouters","forEach","routeName","routeConfig","path","screen","router","Error","map","n","join","resetChildRoute","params","undefined","childRouter","childAction","init","getStateForAction","key","getInitialState","routes","index","isTransitioning","getNextState","prevState","possibleNextState","nextState","prevRouteName","nextRoutes","getActionCreators","stateKey","action","inputState","state","activeChildIndex","type","INIT","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","BACK","didNavigate","NAVIGATE","find","childId","i","childState","newChildState","lastRoute","getComponentForState","getComponentForRouteName","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","navigate","parts","split","pathToTest","partsInTestPath","length","pathPartsToTest","slice","getScreenOptions","navigationOptions"],"mappings":";;;;;;;AAAA,OAAOA,SAAP;AACA,OAAOC,qBAAP;AACA,OAAOC,kBAAP;AAEA,OAAOC,iBAAP;AACA,OAAOC,YAAP;AACA,OAAOC,sBAAP;AACA,OAAOC,2BAAP;;AAEA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACC,KAAD,EAAQC,WAAR;AAAA,SAAyB,EAAzB;AAAA,CAA9B;;AAEA,SAASC,mCAAT,CAA6CC,UAA7C,EAAyD;AACvD,SAAO,CACLR,iBAAiB,CAACS,UADb,EAGLR,YAAY,CAACS,mBAHR,EAILC,QAJK,CAIIH,UAJJ,CAAP;AAKD;;AAED,gBAAe,UAACI,YAAD,EAA+B;AAAA,MAAhBC,MAAgB,uEAAP,EAAO;AAE5CX,EAAAA,sBAAsB,CAACU,YAAD,CAAtB;AAEA,MAAME,KAAK,GAAGD,MAAM,CAACC,KAAP,IAAgBC,MAAM,CAACC,IAAP,CAAYJ,YAAZ,CAA9B;AACA,MAAMK,KAAK,GAAGJ,MAAM,CAACI,KAAP,IAAgB,EAA9B;AACA,MAAMC,uBAAuB,GAC3BL,MAAM,CAACK,uBAAP,IAAkCd,qBADpC;AAGA,MAAMe,kBAAkB,GAAGN,MAAM,CAACM,kBAAlC;AACA,MAAMC,gBAAgB,GAAGP,MAAM,CAACO,gBAAP,IAA2BN,KAAK,CAAC,CAAD,CAAzD;AACA,MAAMO,YAAY,GAAGR,MAAM,CAACQ,YAAP,IAAuB,MAA5C;AACA,MAAMC,gCAAgC,GAAGD,YAAY,KAAK,cAA1D;AACA,MAAME,WAAW,GAAGV,MAAM,CAACW,cAAP,CAAsB,aAAtB,IAChBX,MAAM,CAACU,WADS,GAEhB,IAFJ;AAGA,MAAME,iBAAiB,GAAGX,KAAK,CAACY,OAAN,CAAcN,gBAAd,CAA1B;AACA,MAAMO,YAAY,GAAG,EAArB;AACAb,EAAAA,KAAK,CAACc,OAAN,CAAc,UAAAC,SAAS,EAAI;AACzB,QAAMC,WAAW,GAAGlB,YAAY,CAACiB,SAAD,CAAhC;;AACA,QAAI,CAACZ,KAAK,CAACY,SAAD,CAAV,EAAuB;AACrBZ,MAAAA,KAAK,CAACY,SAAD,CAAL,GACE,OAAOC,WAAW,CAACC,IAAnB,KAA4B,QAA5B,GAAuCD,WAAW,CAACC,IAAnD,GAA0DF,SAD5D;AAED;;AACDF,IAAAA,YAAY,CAACE,SAAD,CAAZ,GAA0B,IAA1B;AACA,QAAMG,MAAM,GAAGlC,qBAAqB,CAACc,YAAD,EAAeiB,SAAf,CAApC;;AACA,QAAIG,MAAM,CAACC,MAAX,EAAmB;AACjBN,MAAAA,YAAY,CAACE,SAAD,CAAZ,GAA0BG,MAAM,CAACC,MAAjC;AACD;AACF,GAXD;;AAYA,MAAIR,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAC5B,UAAM,IAAIS,KAAJ,CACJ,+BAA6Bd,gBAA7B,iCACsBN,KAAK,CAACqB,GAAN,CAAU,UAAAC,CAAC;AAAA,oBAAQA,CAAR;AAAA,KAAX,EAAyBC,IAAzB,CAA8B,IAA9B,CADtB,CADI,CAAN;AAID;;AAED,WAASC,eAAT,CAAyBT,SAAzB,EAAoC;AAClC,QAAMU,MAAM,GACVV,SAAS,KAAKT,gBAAd,GAAiCD,kBAAjC,GAAsDqB,SADxD;AAEA,QAAMC,WAAW,GAAGd,YAAY,CAACE,SAAD,CAAhC;;AACA,QAAIY,WAAJ,EAAiB;AACf,UAAMC,WAAW,GAAG1C,iBAAiB,CAAC2C,IAAlB,EAApB;AACA,+BACKF,WAAW,CAACG,iBAAZ,CAA8BF,WAA9B,CADL;AAEEG,QAAAA,GAAG,EAAEhB,SAFP;AAGEA,QAAAA,SAAS,EAATA,SAHF;AAIEU,QAAAA,MAAM,EAANA;AAJF;AAMD;;AACD,WAAO;AACLM,MAAAA,GAAG,EAAEhB,SADA;AAELA,MAAAA,SAAS,EAATA,SAFK;AAGLU,MAAAA,MAAM,EAANA;AAHK,KAAP;AAKD;;AAED,SAAO;AACLO,IAAAA,eADK,6BACa;AAChB,UAAMC,MAAM,GAAGjC,KAAK,CAACqB,GAAN,CAAUG,eAAV,CAAf;AACA,aAAO;AACLS,QAAAA,MAAM,EAANA,MADK;AAELC,QAAAA,KAAK,EAAEvB,iBAFF;AAGLwB,QAAAA,eAAe,EAAE;AAHZ,OAAP;AAKD,KARI;AAULC,IAAAA,YAVK,wBAUQC,SAVR,EAUmBC,iBAVnB,EAUsC;AACzC,UAAI,CAACD,SAAL,EAAgB;AACd,eAAOC,iBAAP;AACD;;AAED,UAAIC,SAAJ;;AACA,UAAIF,SAAS,CAACH,KAAV,KAAoBI,iBAAiB,CAACJ,KAAtC,IAA+CzB,WAAnD,EAAgE;AAC9D,YAAM+B,aAAa,GAAGH,SAAS,CAACJ,MAAV,CAAiBI,SAAS,CAACH,KAA3B,EAAkCnB,SAAxD;;AACA,YAAM0B,UAAU,sBAAOH,iBAAiB,CAACL,MAAzB,CAAhB;;AACAQ,QAAAA,UAAU,CAACJ,SAAS,CAACH,KAAX,CAAV,GAA8BV,eAAe,CAACgB,aAAD,CAA7C;AAEA,iCACKF,iBADL;AAEEL,UAAAA,MAAM,EAAEQ;AAFV;AAID,OATD,MASO;AACLF,QAAAA,SAAS,GAAGD,iBAAZ;AACD;;AAED,aAAOC,SAAP;AACD,KA9BI;AAgCLG,IAAAA,iBAhCK,6BAgCanD,KAhCb,EAgCoBoD,QAhCpB,EAgC8B;AACjC,+BACKtD,2BAA2B,CAACE,KAAD,CADhC,MAEKa,uBAAuB,CAACb,KAAD,EAAQoD,QAAR,CAF5B;AAID,KArCI;AAuCLb,IAAAA,iBAvCK,6BAuCac,MAvCb,EAuCqBC,UAvCrB,EAuCiC;AACpC,UAAIR,SAAS,GAAGQ,UAAU,qBAAQA,UAAR,IAAuBA,UAAjD;AACA,UAAIC,KAAK,GAAGD,UAAU,IAAI,KAAKb,eAAL,EAA1B;AACA,UAAIe,gBAAgB,GAAGD,KAAK,CAACZ,KAA7B;;AAEA,UAAIU,MAAM,CAACI,IAAP,KAAgB9D,iBAAiB,CAAC+D,IAAtC,EAA4C;AAAA,YAKlCxB,MALkC,GAKvBmB,MALuB,CAKlCnB,MALkC;;AAM1C,YAAIA,MAAJ,EAAY;AACVqB,UAAAA,KAAK,CAACb,MAAN,GAAea,KAAK,CAACb,MAAN,CAAaZ,GAAb,CAAiB,UAAA9B,KAAK;AAAA,qCAChCA,KADgC;AAEnCkC,cAAAA,MAAM,oBACDlC,KAAK,CAACkC,MADL,MAEDA,MAFC,MAGAlC,KAAK,CAACwB,SAAN,KAAoBT,gBAApB,GACAD,kBADA,GAEA,IALA;AAF6B;AAAA,WAAtB,CAAf;AAUD;AACF;;AAGD,UAAM6C,oBAAoB,GAAGJ,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACZ,KAAnB,CAA7B;AACA,UAAMiB,iBAAiB,GAAGtC,YAAY,CAACb,KAAK,CAAC8C,KAAK,CAACZ,KAAP,CAAN,CAAtC;;AACA,UAAIiB,iBAAJ,EAAuB;AACrB,YAAMC,gBAAgB,GAAGD,iBAAiB,CAACrB,iBAAlB,CACvBc,MADuB,EAEvBM,oBAFuB,CAAzB;;AAIA,YAAI,CAACE,gBAAD,IAAqBP,UAAzB,EAAqC;AACnC,iBAAO,IAAP;AACD;;AACD,YAAIO,gBAAgB,IAAIA,gBAAgB,KAAKF,oBAA7C,EAAmE;AACjE,cAAMjB,OAAM,sBAAOa,KAAK,CAACb,MAAb,CAAZ;;AACAA,UAAAA,OAAM,CAACa,KAAK,CAACZ,KAAP,CAAN,GAAsBkB,gBAAtB;AACA,iBAAO,KAAKhB,YAAL,CAAkBC,SAAlB,oBACFS,KADE;AAELb,YAAAA,MAAM,EAANA;AAFK,aAAP;AAID;AACF;;AAID,UAAMoB,cAAc,GAClBT,MAAM,CAACb,GAAP,IAAc,IAAd,IAAsBa,MAAM,CAACb,GAAP,KAAemB,oBAAoB,CAACnB,GAD5D;;AAEA,UAAIa,MAAM,CAACI,IAAP,KAAgB9D,iBAAiB,CAACoE,IAAtC,EAA4C;AAC1C,YAAID,cAAc,IAAI7C,gCAAtB,EAAwD;AACtDuC,UAAAA,gBAAgB,GAAGpC,iBAAnB;AACD,SAFD,MAEO;AACL,iBAAOmC,KAAP;AACD;AACF;;AAED,UAAIS,WAAW,GAAG,KAAlB;;AACA,UAAIX,MAAM,CAACI,IAAP,KAAgB9D,iBAAiB,CAACsE,QAAtC,EAAgD;AAC9CD,QAAAA,WAAW,GAAG,CAAC,CAACvD,KAAK,CAACyD,IAAN,CAAW,UAACC,OAAD,EAAUC,CAAV,EAAgB;AACzC,cAAID,OAAO,KAAKd,MAAM,CAAC7B,SAAvB,EAAkC;AAChCgC,YAAAA,gBAAgB,GAAGY,CAAnB;AACA,mBAAO,IAAP;AACD;;AACD,iBAAO,KAAP;AACD,SANe,CAAhB;;AAOA,YAAIJ,WAAJ,EAAiB;AACf,cAAMK,UAAU,GAAGd,KAAK,CAACb,MAAN,CAAac,gBAAb,CAAnB;AACA,cAAMpB,WAAW,GAAGd,YAAY,CAAC+B,MAAM,CAAC7B,SAAR,CAAhC;AACA,cAAI8C,aAAJ;;AAEA,cAAIjB,MAAM,CAACA,MAAX,EAAmB;AACjBiB,YAAAA,aAAa,GAAGlC,WAAW,GACvBA,WAAW,CAACG,iBAAZ,CAA8Bc,MAAM,CAACA,MAArC,EAA6CgB,UAA7C,CADuB,GAEvB,IAFJ;AAGD,WAJD,MAIO,IAAI,CAAChB,MAAM,CAACA,MAAR,IAAkB,CAACjB,WAAnB,IAAkCiB,MAAM,CAACnB,MAA7C,EAAqD;AAC1DoC,YAAAA,aAAa,qBACRD,UADQ;AAEXnC,cAAAA,MAAM,oBACAmC,UAAU,CAACnC,MAAX,IAAqB,EADrB,MAEDmB,MAAM,CAACnB,MAFN;AAFK,cAAb;AAOD;;AAED,cAAIoC,aAAa,IAAIA,aAAa,KAAKD,UAAvC,EAAmD;AACjD,gBAAM3B,QAAM,sBAAOa,KAAK,CAACb,MAAb,CAAZ;;AACAA,YAAAA,QAAM,CAACc,gBAAD,CAAN,GAA2Bc,aAA3B;AACA,mBAAO,KAAKzB,YAAL,CAAkBC,SAAlB,oBACFS,KADE;AAELb,cAAAA,MAAM,EAANA,QAFK;AAGLC,cAAAA,KAAK,EAAEa;AAHF,eAAP;AAKD,WARD,MAQO,IACL,CAACc,aAAD,IACAf,KAAK,CAACZ,KAAN,KAAgBa,gBADhB,IAEAV,SAHK,EAIL;AACA,mBAAO,IAAP;AACD;AACF;AACF;;AAED,UAAIO,MAAM,CAACI,IAAP,KAAgB9D,iBAAiB,CAACS,UAAtC,EAAkD;AAChD,YAAMoC,GAAG,GAAGa,MAAM,CAACb,GAAnB;AACA,YAAM+B,SAAS,GAAGhB,KAAK,CAACb,MAAN,CAAawB,IAAb,CAAkB,UAAAlE,KAAK;AAAA,iBAAIA,KAAK,CAACwC,GAAN,KAAcA,GAAlB;AAAA,SAAvB,CAAlB;;AACA,YAAI+B,SAAJ,EAAe;AACb,cAAMrC,OAAM,qBACPqC,SAAS,CAACrC,MADH,MAEPmB,MAAM,CAACnB,MAFA,CAAZ;;AAIA,cAAMQ,QAAM,sBAAOa,KAAK,CAACb,MAAb,CAAZ;;AACAA,UAAAA,QAAM,CAACa,KAAK,CAACb,MAAN,CAAarB,OAAb,CAAqBkD,SAArB,CAAD,CAAN,qBACKA,SADL;AAEErC,YAAAA,MAAM,EAANA;AAFF;AAIA,iBAAO,KAAKW,YAAL,CAAkBC,SAAlB,oBACFS,KADE;AAELb,YAAAA,MAAM,EAANA;AAFK,aAAP;AAID;AACF;;AAED,UAAIc,gBAAgB,KAAKD,KAAK,CAACZ,KAA/B,EAAsC;AACpC,eAAO,KAAKE,YAAL,CAAkBC,SAAlB,oBACFS,KADE;AAELZ,UAAAA,KAAK,EAAEa;AAFF,WAAP;AAID,OALD,MAKO,IAAIQ,WAAW,IAAI,CAACV,UAApB,EAAgC;AACrC,eAAOC,KAAP;AACD,OAFM,MAEA,IAAIS,WAAJ,EAAiB;AACtB,iCAAYT,KAAZ;AACD;;AAGD,UAAIZ,KAAK,GAAGY,KAAK,CAACZ,KAAlB;AACA,UAAID,MAAM,GAAGa,KAAK,CAACb,MAAnB;AACAjC,MAAAA,KAAK,CAACyD,IAAN,CAAW,UAACC,OAAD,EAAUC,CAAV,EAAgB;AACzB,YAAMhC,WAAW,GAAGd,YAAY,CAAC6C,OAAD,CAAhC;;AACA,YAAIC,CAAC,KAAKzB,KAAV,EAAiB;AACf,iBAAO,KAAP;AACD;;AACD,YAAI0B,UAAU,GAAG3B,MAAM,CAAC0B,CAAD,CAAvB;;AACA,YAAIhC,WAAJ,EAAiB;AACfiC,UAAAA,UAAU,GAAGjC,WAAW,CAACG,iBAAZ,CAA8Bc,MAA9B,EAAsCgB,UAAtC,CAAb;AACD;;AACD,YAAI,CAACA,UAAL,EAAiB;AACf1B,UAAAA,KAAK,GAAGyB,CAAR;AACA,iBAAO,IAAP;AACD;;AACD,YAAIC,UAAU,KAAK3B,MAAM,CAAC0B,CAAD,CAAzB,EAA8B;AAC5B1B,UAAAA,MAAM,sBAAOA,MAAP,CAAN;AACAA,UAAAA,MAAM,CAAC0B,CAAD,CAAN,GAAYC,UAAZ;AACA1B,UAAAA,KAAK,GAAGyB,CAAR;AACA,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD,OApBD;;AA0BA,UAAIlE,mCAAmC,CAACmD,MAAM,CAACI,IAAR,CAAvC,EAAsD;AACpDd,QAAAA,KAAK,GAAGY,KAAK,CAACZ,KAAd;AACD;;AAED,UAAIA,KAAK,KAAKY,KAAK,CAACZ,KAAhB,IAAyBD,MAAM,KAAKa,KAAK,CAACb,MAA9C,EAAsD;AACpD,eAAO,KAAKG,YAAL,CAAkBC,SAAlB,oBACFS,KADE;AAELZ,UAAAA,KAAK,EAALA,KAFK;AAGLD,UAAAA,MAAM,EAANA;AAHK,WAAP;AAKD;;AACD,aAAOa,KAAP;AACD,KAvNI;AAyNLiB,IAAAA,oBAzNK,gCAyNgBjB,KAzNhB,EAyNuB;AAC1B,UAAM/B,SAAS,GAAG+B,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACZ,KAAnB,EAA0BnB,SAA5C;AACAhC,MAAAA,SAAS,CACPgC,SADO,2CAEgC+B,KAAK,CAACZ,KAFtC,gGAAT;AAKA,UAAMP,WAAW,GAAGd,YAAY,CAACE,SAAD,CAAhC;;AACA,UAAIY,WAAJ,EAAiB;AACf,eAAOA,WAAW,CAACoC,oBAAZ,CAAiCjB,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACZ,KAAnB,CAAjC,CAAP;AACD;;AACD,aAAOlD,qBAAqB,CAACc,YAAD,EAAeiB,SAAf,CAA5B;AACD,KArOI;AAuOLiD,IAAAA,wBAvOK,oCAuOoBjD,SAvOpB,EAuO+B;AAClC,aAAO/B,qBAAqB,CAACc,YAAD,EAAeiB,SAAf,CAA5B;AACD,KAzOI;AA2OLkD,IAAAA,wBA3OK,oCA2OoBnB,KA3OpB,EA2O2B;AAC9B,UAAMvD,KAAK,GAAGuD,KAAK,CAACb,MAAN,CAAaa,KAAK,CAACZ,KAAnB,CAAd;AACA,UAAMnB,SAAS,GAAGf,KAAK,CAAC8C,KAAK,CAACZ,KAAP,CAAvB;AACA,UAAMgC,OAAO,GAAG/D,KAAK,CAACY,SAAD,CAArB;AACA,UAAMG,MAAM,GAAGlC,qBAAqB,CAACc,YAAD,EAAeiB,SAAf,CAApC;AACA,UAAIE,IAAI,GAAGiD,OAAX;AACA,UAAIzC,MAAM,GAAGlC,KAAK,CAACkC,MAAnB;;AACA,UAAIP,MAAM,IAAIA,MAAM,CAACC,MAArB,EAA6B;AAC3B,YAAMgD,UAAU,GAAG5E,KAAnB;AAGA,YAAM6E,KAAK,GAAGlD,MAAM,CAACC,MAAP,CAAc8C,wBAAd,CAAuCE,UAAvC,CAAd;AACAlD,QAAAA,IAAI,GAAGiD,OAAO,GAAMA,OAAN,SAAiBE,KAAK,CAACnD,IAAvB,GAAgCmD,KAAK,CAACnD,IAApD;AACAQ,QAAAA,MAAM,GAAG2C,KAAK,CAAC3C,MAAN,qBAAoBA,MAApB,MAA+B2C,KAAK,CAAC3C,MAArC,IAAgDA,MAAzD;AACD;;AACD,aAAO;AACLR,QAAAA,IAAI,EAAJA,IADK;AAELQ,QAAAA,MAAM,EAANA;AAFK,OAAP;AAID,KA9PI;AAqQL4C,IAAAA,yBArQK,qCAqQqBpD,IArQrB,EAqQ2BQ,MArQ3B,EAqQmC;AACtC,UAAI,CAACR,IAAL,EAAW;AACT,eAAO/B,iBAAiB,CAACoF,QAAlB,CAA2B;AAChCvD,UAAAA,SAAS,EAAET,gBADqB;AAEhCmB,UAAAA,MAAM,EAANA;AAFgC,SAA3B,CAAP;AAID;;AACD,aACEzB,KAAK,CACFqB,GADH,CACO,UAAAqC,OAAO,EAAI;AACd,YAAMa,KAAK,GAAGtD,IAAI,CAACuD,KAAL,CAAW,GAAX,CAAd;AACA,YAAMC,UAAU,GAAGtE,KAAK,CAACuD,OAAD,CAAxB;AACA,YAAMgB,eAAe,GAAGD,UAAU,CAACD,KAAX,CAAiB,GAAjB,EAAsBG,MAA9C;AACA,YAAMC,eAAe,GAAGL,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAeH,eAAf,EAAgCnD,IAAhC,CAAqC,GAArC,CAAxB;;AACA,YAAIqD,eAAe,KAAKH,UAAxB,EAAoC;AAClC,cAAM9C,WAAW,GAAGd,YAAY,CAAC6C,OAAD,CAAhC;AACA,cAAMd,MAAM,GAAG1D,iBAAiB,CAACoF,QAAlB,CAA2B;AACxCvD,YAAAA,SAAS,EAAE2C;AAD6B,WAA3B,CAAf;;AAGA,cAAI/B,WAAW,IAAIA,WAAW,CAAC0C,yBAA/B,EAA0D;AACxDzB,YAAAA,MAAM,CAACA,MAAP,GAAgBjB,WAAW,CAAC0C,yBAAZ,CACdE,KAAK,CAACM,KAAN,CAAYH,eAAZ,EAA6BnD,IAA7B,CAAkC,GAAlC,CADc,EAEdE,MAFc,CAAhB;AAID;;AACD,cAAIA,MAAJ,EAAY;AACVmB,YAAAA,MAAM,CAACnB,MAAP,GAAgBA,MAAhB;AACD;;AACD,iBAAOmB,MAAP;AACD;;AACD,eAAO,IAAP;AACD,OAvBH,EAwBGa,IAxBH,CAwBQ,UAAAb,MAAM;AAAA,eAAI,CAAC,CAACA,MAAN;AAAA,OAxBd,KAyBA5C,KAAK,CACFqB,GADH,CACO,UAAAqC,OAAO,EAAI;AACd,YAAM/B,WAAW,GAAGd,YAAY,CAAC6C,OAAD,CAAhC;AACA,eACE/B,WAAW,IAAIA,WAAW,CAAC0C,yBAAZ,CAAsCpD,IAAtC,EAA4CQ,MAA5C,CADjB;AAGD,OANH,EAOGgC,IAPH,CAOQ,UAAAb,MAAM;AAAA,eAAI,CAAC,CAACA,MAAN;AAAA,OAPd,CAzBA,IAiCA,IAlCF;AAoCD,KAhTI;AAkTLkC,IAAAA,gBAAgB,EAAE7F,kBAAkB,CAClCa,YADkC,EAElCC,MAAM,CAACgF,iBAF2B;AAlT/B,GAAP;AAuTD,CAhXD","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getNavigationActionCreators from './getNavigationActionCreators';\n\nconst defaultActionCreators = (route, navStateKey) => ({});\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [\n    NavigationActions.SET_PARAMS,\n    // Todo: make SwitchRouter not depend on StackActions..\n    StackActions.COMPLETE_TRANSITION,\n  ].includes(actionType);\n}\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n  const paths = config.paths || {};\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const childRouters = {};\n  order.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    if (!paths[routeName]) {\n      paths[routeName] =\n        typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    }\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  function resetChildRoute(routeName) {\n    const params =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  return {\n    getInitialState() {\n      const routes = order.map(resetChildRoute);\n      return {\n        routes,\n        index: initialRouteIndex,\n        isTransitioning: false,\n      };\n    },\n\n    getNextState(prevState, possibleNextState) {\n      if (!prevState) {\n        return possibleNextState;\n      }\n\n      let nextState;\n      if (prevState.index !== possibleNextState.index && resetOnBlur) {\n        const prevRouteName = prevState.routes[prevState.index].routeName;\n        const nextRoutes = [...possibleNextState.routes];\n        nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n\n        return {\n          ...possibleNextState,\n          routes: nextRoutes,\n        };\n      } else {\n        nextState = possibleNextState;\n      }\n\n      return nextState;\n    },\n\n    getActionCreators(route, stateKey) {\n      return {\n        ...getNavigationActionCreators(route),\n        ...getCustomActionCreators(route, stateKey),\n      };\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || this.getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return this.getNextState(prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && shouldBackNavigateToInitialRoute) {\n          activeChildIndex = initialRouteIndex;\n        } else {\n          return state;\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState;\n\n          if (action.action) {\n            newChildState = childRouter\n              ? childRouter.getStateForAction(action.action, childState)\n              : null;\n          } else if (!action.action && !childRouter && action.params) {\n            newChildState = {\n              ...childState,\n              params: {\n                ...(childState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            return this.getNextState(prevState, {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            });\n          } else if (\n            !newChildState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return this.getNextState(prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return this.getNextState(prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      // Let other children handle it and switch to the first child that returns a new state\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n        if (i === index) {\n          return false;\n        }\n        let childState = routes[i];\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n        if (!childState) {\n          index = i;\n          return true;\n        }\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n\n      // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return this.getNextState(prevState, {\n          ...state,\n          index,\n          routes,\n        });\n      }\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      const routeName = order[state.index];\n      const subPath = paths[routeName];\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        const stateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    /**\n     * Gets an optional action, based on a relative path and query params.\n     *\n     * This will return null if there is no action matched\n     */\n    getActionForPathAndParams(path, params) {\n      if (!path) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n          params,\n        });\n      }\n      return (\n        order\n          .map(childId => {\n            const parts = path.split('/');\n            const pathToTest = paths[childId];\n            const partsInTestPath = pathToTest.split('/').length;\n            const pathPartsToTest = parts.slice(0, partsInTestPath).join('/');\n            if (pathPartsToTest === pathToTest) {\n              const childRouter = childRouters[childId];\n              const action = NavigationActions.navigate({\n                routeName: childId,\n              });\n              if (childRouter && childRouter.getActionForPathAndParams) {\n                action.action = childRouter.getActionForPathAndParams(\n                  parts.slice(partsInTestPath).join('/'),\n                  params\n                );\n              }\n              if (params) {\n                action.params = params;\n              }\n              return action;\n            }\n            return null;\n          })\n          .find(action => !!action) ||\n        order\n          .map(childId => {\n            const childRouter = childRouters[childId];\n            return (\n              childRouter && childRouter.getActionForPathAndParams(path, params)\n            );\n          })\n          .find(action => !!action) ||\n        null\n      );\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.navigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}