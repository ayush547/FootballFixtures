{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _jsxFileName = \"/home/narensairam/Desktop/react-native/fixtures/node_modules/react-navigation/src/createNavigationContainer.js\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport { polyfill } from 'react-lifecycles-compat';\nimport { BackHandler } from \"./PlatformHelpers\";\nimport NavigationActions from \"./NavigationActions\";\nimport invariant from \"./utils/invariant\";\nimport getNavigationActionCreators from \"./routers/getNavigationActionCreators\";\nimport docsUrl from \"./utils/docsUrl\";\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (isStateful(props)) {\n    return;\n  }\n\n  var navigation = props.navigation,\n      screenProps = props.screenProps,\n      containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + (\"unclear if it should own its own state. Remove props: \\\"\" + keys.join(', ') + \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n}\n\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  var NavigationContainer = function (_React$Component) {\n    _inherits(NavigationContainer, _React$Component);\n\n    var _super = _createSuper(NavigationContainer);\n\n    _createClass(NavigationContainer, null, [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps, prevState) {\n        validateProps(nextProps);\n        return null;\n      }\n    }]);\n\n    function NavigationContainer(props) {\n      var _this;\n\n      _classCallCheck(this, NavigationContainer);\n\n      _this = _super.call(this, props);\n      _this.subs = null;\n      _this._actionEventSubscribers = new Set();\n\n      _this._handleOpenURL = function (_ref) {\n        var url = _ref.url;\n\n        var parsedUrl = _this._urlToPathAndParams(url);\n\n        if (parsedUrl) {\n          var path = parsedUrl.path,\n              params = parsedUrl.params;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            _this.dispatch(action);\n          }\n        }\n      };\n\n      _this._persistNavigationState = function _callee(nav) {\n        var persistenceKey;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                persistenceKey = _this.props.persistenceKey;\n\n                if (persistenceKey) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return _regeneratorRuntime.awrap(AsyncStorage.setItem(persistenceKey, JSON.stringify(nav)));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      };\n\n      _this.dispatch = function (action) {\n        if (_this.props.navigation) {\n          return _this.props.navigation.dispatch(action);\n        }\n\n        _this._navState = _this._navState || _this.state.nav;\n        var lastNavState = _this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = function dispatchActionEvents() {\n          _this._actionEventSubscribers.forEach(function (subscriber) {\n            return subscriber({\n              type: 'action',\n              action: action,\n              state: navState,\n              lastState: lastNavState\n            });\n          });\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          _this._navState = navState;\n\n          _this.setState({\n            nav: navState\n          }, function () {\n            _this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            _this._persistNavigationState(navState);\n          });\n\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      };\n\n      validateProps(props);\n      _this._initialAction = NavigationActions.init();\n\n      if (_this._isStateful()) {\n        _this.subs = BackHandler.addEventListener('hardwareBackPress', function () {\n          if (!_this._isMounted) {\n            _this.subs && _this.subs.remove();\n          } else {\n            return _this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      _this.state = {\n        nav: _this._isStateful() && !props.persistenceKey ? Component.router.getStateForAction(_this._initialAction) : null\n      };\n      return _this;\n    }\n\n    _createClass(NavigationContainer, [{\n      key: \"_renderLoading\",\n      value: function _renderLoading() {\n        return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n      }\n    }, {\n      key: \"_isStateful\",\n      value: function _isStateful() {\n        return isStateful(this.props);\n      }\n    }, {\n      key: \"_validateProps\",\n      value: function _validateProps(props) {\n        if (this._isStateful()) {\n          return;\n        }\n\n        var navigation = props.navigation,\n            screenProps = props.screenProps,\n            containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n\n        var keys = Object.keys(containerProps);\n\n        if (keys.length !== 0) {\n          throw new Error('This navigator has both navigation and container props, so it is ' + (\"unclear if it should own its own state. Remove props: \\\"\" + keys.join(', ') + \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n        }\n      }\n    }, {\n      key: \"_urlToPathAndParams\",\n      value: function _urlToPathAndParams(url) {\n        var params = {};\n        var delimiter = this.props.uriPrefix || '://';\n        var path = url.split(delimiter)[1];\n\n        if (typeof path === 'undefined') {\n          path = url;\n        } else if (path === '') {\n          path = '/';\n        }\n\n        return {\n          path: path,\n          params: params\n        };\n      }\n    }, {\n      key: \"_onNavigationStateChange\",\n      value: function _onNavigationStateChange(prevNav, nav, action) {\n        if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n          if (console.group) {\n            console.group('Navigation Dispatch: ');\n            console.log('Action: ', action);\n            console.log('New State: ', nav);\n            console.log('Last State: ', prevNav);\n            console.groupEnd();\n          } else {\n            console.log('Navigation Dispatch: ', {\n              action: action,\n              newState: nav,\n              lastState: prevNav\n            });\n          }\n\n          return;\n        }\n\n        if (typeof this.props.onNavigationStateChange === 'function') {\n          this.props.onNavigationStateChange(prevNav, nav, action);\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        if (this._navState === this.state.nav) {\n          this._navState = null;\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        var persistenceKey, startupStateJSON, url, parsedUrl, action, startupState, path, params, urlAction, dispatchActions;\n        return _regeneratorRuntime.async(function componentDidMount$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._isMounted = true;\n\n                if (this._isStateful()) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                if (__DEV__ && !this.props.detached) {\n                  if (_statefulContainerCount > 0) {\n                    console.error(\"You should only render one navigator explicitly in your app, and other navigators should by rendered by including them in that navigator. Full details at: \" + docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator'));\n                  }\n                }\n\n                _statefulContainerCount++;\n                Linking.addEventListener('url', this._handleOpenURL);\n                persistenceKey = this.props.persistenceKey;\n                _context2.t0 = persistenceKey;\n\n                if (!_context2.t0) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                _context2.next = 11;\n                return _regeneratorRuntime.awrap(AsyncStorage.getItem(persistenceKey));\n\n              case 11:\n                _context2.t0 = _context2.sent;\n\n              case 12:\n                startupStateJSON = _context2.t0;\n                _context2.next = 15;\n                return _regeneratorRuntime.awrap(Linking.getInitialURL());\n\n              case 15:\n                url = _context2.sent;\n                parsedUrl = url && this._urlToPathAndParams(url);\n                action = this._initialAction;\n                startupState = this.state.nav;\n\n                if (!startupState) {\n                  !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n                  startupState = Component.router.getStateForAction(action);\n                }\n\n                if (startupStateJSON) {\n                  try {\n                    startupState = JSON.parse(startupStateJSON);\n                    _reactNavigationIsHydratingState = true;\n                  } catch (e) {}\n                }\n\n                if (parsedUrl) {\n                  path = parsedUrl.path, params = parsedUrl.params;\n                  urlAction = Component.router.getActionForPathAndParams(path, params);\n\n                  if (urlAction) {\n                    !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', url);\n                    action = urlAction;\n                    startupState = Component.router.getStateForAction(urlAction, startupState);\n                  }\n                }\n\n                dispatchActions = function dispatchActions() {\n                  return _this2._actionEventSubscribers.forEach(function (subscriber) {\n                    return subscriber({\n                      type: 'action',\n                      action: action,\n                      state: _this2.state.nav,\n                      lastState: null\n                    });\n                  });\n                };\n\n                if (!(startupState === this.state.nav)) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                dispatchActions();\n                return _context2.abrupt(\"return\");\n\n              case 26:\n                this.setState({\n                  nav: startupState\n                }, function () {\n                  _reactNavigationIsHydratingState = false;\n                  dispatchActions();\n                });\n\n              case 27:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, this, null, Promise);\n      }\n    }, {\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(e, errorInfo) {\n        if (_reactNavigationIsHydratingState) {\n          _reactNavigationIsHydratingState = false;\n          console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state..');\n          this.dispatch(NavigationActions.init());\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._isMounted = false;\n        Linking.removeEventListener('url', this._handleOpenURL);\n        this.subs && this.subs.remove();\n\n        if (this._isStateful()) {\n          _statefulContainerCount--;\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var navigation = this.props.navigation;\n\n        if (this._isStateful()) {\n          var nav = this.state.nav;\n\n          if (!nav) {\n            return this._renderLoading();\n          }\n\n          if (!this._navigation || this._navigation.state !== nav) {\n            this._navigation = {\n              dispatch: this.dispatch,\n              state: nav,\n              addListener: function addListener(eventName, handler) {\n                if (eventName !== 'action') {\n                  return {\n                    remove: function remove() {}\n                  };\n                }\n\n                _this3._actionEventSubscribers.add(handler);\n\n                return {\n                  remove: function remove() {\n                    _this3._actionEventSubscribers.delete(handler);\n                  }\n                };\n              }\n            };\n            var actionCreators = getNavigationActionCreators(nav);\n            Object.keys(actionCreators).forEach(function (actionName) {\n              _this3._navigation[actionName] = function () {\n                return _this3.dispatch(actionCreators[actionName].apply(actionCreators, arguments));\n              };\n            });\n          }\n\n          navigation = this._navigation;\n        }\n\n        invariant(navigation, 'failed to get navigation');\n        return React.createElement(Component, _extends({}, this.props, {\n          navigation: navigation,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 387,\n            columnNumber: 14\n          }\n        }));\n      }\n    }]);\n\n    return NavigationContainer;\n  }(React.Component);\n\n  NavigationContainer.router = Component.router;\n  NavigationContainer.navigationOptions = null;\n  return polyfill(NavigationContainer);\n}","map":{"version":3,"sources":["/home/narensairam/Desktop/react-native/fixtures/node_modules/react-navigation/src/createNavigationContainer.js"],"names":["React","polyfill","BackHandler","NavigationActions","invariant","getNavigationActionCreators","docsUrl","isStateful","props","navigation","validateProps","screenProps","containerProps","keys","Object","length","Error","join","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","nextProps","prevState","subs","_actionEventSubscribers","Set","_handleOpenURL","url","parsedUrl","_urlToPathAndParams","path","params","action","router","getActionForPathAndParams","dispatch","_persistNavigationState","nav","persistenceKey","AsyncStorage","setItem","JSON","stringify","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_initialAction","init","_isStateful","addEventListener","_isMounted","remove","back","renderLoadingExperimental","delimiter","uriPrefix","split","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","console","group","log","groupEnd","newState","__DEV__","detached","error","Linking","getItem","startupStateJSON","getInitialURL","startupState","parse","e","urlAction","dispatchActions","errorInfo","warn","removeEventListener","_renderLoading","_navigation","addListener","eventName","handler","add","delete","actionCreators","actionName","navigationOptions"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { Linking, AsyncStorage } from 'react-native';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport { BackHandler } from './PlatformHelpers';\nimport NavigationActions from './NavigationActions';\nimport invariant from './utils/invariant';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport docsUrl from './utils/docsUrl';\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (isStateful(props)) {\n    return;\n  }\n\n  const { navigation, screenProps, ...containerProps } = props;\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error(\n      'This navigator has both navigation and container props, so it is ' +\n        `unclear if it should own its own state. Remove props: \"${keys.join(\n          ', '\n        )}\" ` +\n        'if the navigator should get its state from the navigation prop. If the ' +\n        'navigator should maintain its own state, do not pass a navigation prop.'\n    );\n  }\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful()) {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav:\n          this._isStateful() && !props.persistenceKey\n            ? Component.router.getStateForAction(this._initialAction)\n            : null,\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental\n        ? this.props.renderLoadingExperimental()\n        : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      const { navigation, screenProps, ...containerProps } = props;\n\n      const keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error(\n          'This navigator has both navigation and container props, so it is ' +\n            `unclear if it should own its own state. Remove props: \"${keys.join(\n              ', '\n            )}\" ` +\n            'if the navigator should get its state from the navigation prop. If the ' +\n            'navigator should maintain its own state, do not pass a navigation prop.'\n        );\n      }\n    }\n\n    _urlToPathAndParams(url) {\n      const params = {};\n      const delimiter = this.props.uriPrefix || '://';\n      let path = url.split(delimiter)[1];\n      if (typeof path === 'undefined') {\n        path = url;\n      } else if (path === '') {\n        path = '/';\n      }\n      return {\n        path,\n        params,\n      };\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const parsedUrl = this._urlToPathAndParams(url);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (\n        typeof this.props.onNavigationStateChange === 'undefined' &&\n        this._isStateful() &&\n        !!process.env.REACT_NAV_LOGGING\n      ) {\n        /* eslint-disable no-console */\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav,\n          });\n        }\n        /* eslint-enable no-console */\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (__DEV__ && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          console.error(\n            `You should only render one navigator explicitly in your app, and other navigators should by rendered by including them in that navigator. Full details at: ${docsUrl(\n              'common-mistakes.html#explicitly-rendering-more-than-one-navigator'\n            )}`\n          );\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      const { persistenceKey } = this.props;\n      const startupStateJSON =\n        persistenceKey && (await AsyncStorage.getItem(persistenceKey));\n      const url = await Linking.getInitialURL();\n      const parsedUrl = url && this._urlToPathAndParams(url);\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      let startupState = this.state.nav;\n      if (!startupState) {\n        !!process.env.REACT_NAV_LOGGING &&\n          console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull persisted state from AsyncStorage\n      if (startupStateJSON) {\n        try {\n          startupState = JSON.parse(startupStateJSON);\n          _reactNavigationIsHydratingState = true;\n        } catch (e) {}\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(\n          path,\n          params\n        );\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING &&\n            console.log('Applying Navigation Action for Initial URL:', url);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(\n            urlAction,\n            startupState\n          );\n        }\n      }\n\n      const dispatchActions = () =>\n        this._actionEventSubscribers.forEach(subscriber =>\n          subscriber({\n            type: 'action',\n            action,\n            state: this.state.nav,\n            lastState: null,\n          })\n        );\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    componentDidCatch(e, errorInfo) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn(\n          'Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state..'\n        );\n        this.dispatch(NavigationActions.init());\n      }\n    }\n\n    _persistNavigationState = async nav => {\n      const { persistenceKey } = this.props;\n      if (!persistenceKey) {\n        return;\n      }\n      await AsyncStorage.setItem(persistenceKey, JSON.stringify(nav));\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = action => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(\n        action,\n        lastNavState\n      );\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach(subscriber =>\n          subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState,\n          })\n        );\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const nav = this.state.nav;\n        if (!nav) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== nav) {\n          this._navigation = {\n            dispatch: this.dispatch,\n            state: nav,\n            addListener: (eventName, handler) => {\n              if (eventName !== 'action') {\n                return { remove: () => {} };\n              }\n              this._actionEventSubscribers.add(handler);\n              return {\n                remove: () => {\n                  this._actionEventSubscribers.delete(handler);\n                },\n              };\n            },\n          };\n          const actionCreators = getNavigationActionCreators(nav);\n          Object.keys(actionCreators).forEach(actionName => {\n            this._navigation[actionName] = (...args) =>\n              this.dispatch(actionCreators[actionName](...args));\n          });\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return <Component {...this.props} navigation={navigation} />;\n    }\n  }\n\n  return polyfill(NavigationContainer);\n}\n"]},"metadata":{},"sourceType":"module"}